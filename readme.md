# Task

**Надо запустить в кубере несколько микросервисов, которые сообща будут решать задачу fizzbuzz. При необходимости, сервисы должны уметь масштабироваться.**

## С точки зрения пользователя:

- есть вебсервис, который принимает число и возвращает:
  - fizz, если число делится на N (но не M)
  - buzz, если число делится на M (но не N)
  - fizzbuzz, если число делится на N и на M
  - исходное число -- в остальных случаях


## С точки зрения админа кубера:

- есть deployment fizzbuzz
- в deployment'е 4 replicasets: fizz, buzz, concat, main -- микросервисы

- main:
  - взаимодействует с пользователем, соответственно есть ingress, проброшен порт и т.п.
  - получает пользовательские данные, возвращает ответ, но не вычисляет его, вместо этого посылает запросы другим сервисам
  - мониторит ситуацию с количеством сообщений и масштабирует другие реплики (путём запросов к куберу)

- fizz, buzz, concat:
  - просто вычисляют ответ в соответствии с ТЗ
  
## С точки зрения бэкэнд-разработчика (описания хэндлеров):

- main:
  - POST /fizzbuzz, тело: {"value": 42}. ответ: {"result": "fizz"}
- fizz:
  - GET /fizz?value=42, ответ: {"result": "fizz"}
- buzz:
  - GET /buzz?value=42, ответ: {"result": ""}
- concat:
  - GET /concat?lhs=fizz&rhs=, ответ: {"result": "fizz"}

## DOD:

- пользователь осуществляет POST-запросы и получает на них корректные ответы
- во время нагрузочного тестирования создаются дополнительные реплики 
- после нагрузочного тестирования количество реплик возвращается к 1
- (под вопросом) во время нагрузочного тестирование количество реплик concat должно быть примерно равно сумме fizz и buzz

### Темы для дополнительного исследования:

- как масштабировать (в кубере есть autoscaling, но имеет смысл попробовать на ручнике REST-запросами к куберу)
- main содержит state (очередь сообщений и частично-обработанных запросов), если его реплицировать, то каждый инстанс main не будет знать, сколько сообщений всего. Подумать об организовации масштабирования остальных сервисов в этом случае
- ограничить ресурсы и попытаться найти оптимум между количеством реплик и утилизацией ресурсов под нагрузкой (слишком много реплик -- оверхед, мало реплик -- медленнее обработка очереди)